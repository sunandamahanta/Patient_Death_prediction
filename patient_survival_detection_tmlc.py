# -*- coding: utf-8 -*-
"""Patient_Survival_Detection_tmlc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lAxB3EIerWMxD7THyP2ngQSPJfkyjYKS
"""

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os
import PIL
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D

# %matplotlib inline

# Suppressing Warnings
import warnings
warnings.filterwarnings('ignore')

from google.colab import drive
drive.mount('/content/gdrive')

data = pd.read_csv("/content/gdrive/MyDrive/Dataset.csv")
data_dict = pd.read_csv("/content/gdrive/MyDrive/Data Dictionary.csv")
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)

data.head()

data_dict

data.shape

data.info(verbose=True, null_counts=True)

data.describe()

cols = ['encounter_id','patient_id','hospital_id']
data.duplicated(subset=cols).sum()

data.drop(cols,axis=1,inplace=True)

data.drop('readmission_status',axis=1,inplace=True)

#Pie Chart Visualisation
death = data['hospital_death'].value_counts().to_frame('counts')
my_circle = plt.Circle((0,0),0.7,color='white')
plt.pie(death.counts,labels=['Death','Survive'],colors=['red','green'],autopct='%1.1f%%')
p = plt.gcf()
p.gca().add_artist(my_circle)
plt.show()

#Violin plot on Original attributes to visualize the spread of the data
plt.figure(figsize = (15,10))
plt.subplot(4,1,1)
sns.violinplot( x = 'age', data = data)
plt.subplot(4,1,2)
sns.violinplot( x = 'bmi', data = data)
plt.subplot(4,1,3)
sns.violinplot( x = 'height', data=data)
plt.subplot(4,1,4)
sns.violinplot( x = 'weight', data=data)
plt.show()

demo2 = ['ethnicity', 'gender', 'elective_surgery']
plt.figure(figsize=(18,12))

i=1
for col in demo2:
    plt.subplot(2,3,i)
    sns.set_style("whitegrid")
    sns.countplot(data[col])
    plt.xticks(rotation=90)
    i+=1

plt.show()

demo3 = ['hospital_admit_source', 'icu_admit_source']
plt.figure(figsize=(18,12))

i=1
for col in demo3:
    plt.subplot(1,2,i)
    sns.set_style("whitegrid")
    sns.countplot(data[col])
    plt.xticks(rotation=60)
    i+=1

plt.show()

demo4 = ['icu_stay_type', 'icu_type']
plt.figure(figsize=(18,12))

i=1
for col in demo4:
    plt.subplot(1,2,i)
    sns.set_style("whitegrid")
    sns.countplot(data[col])
    plt.xticks(rotation=60)
    i+=1

plt.show()

sns.set_style("whitegrid")
sns.distplot(data['pre_icu_los_days'])
plt.xticks(rotation=60)
plt.show()

apache=['albumin_apache', 'apache_2_diagnosis', 'apache_3j_diagnosis', 'apache_post_operative', 'arf_apache', 'bilirubin_apache', 'bun_apache', 'creatinine_apache', 'fio2_apache']

#Countplot on above Columns
plt.figure(figsize=(20,20))
i=0
for col in apache:
    plt.subplot(3,3,i+1)
    sns.set_style("whitegrid")
    sns.distplot(data[col])
    i+=1
    
plt.show()

gcs=['gcs_eyes_apache', 'gcs_motor_apache', 'gcs_unable_apache', 'gcs_verbal_apache']

#Countplot on above Columns
plt.figure(figsize=(20,20))
i=0
for col in gcs:
    plt.subplot(4,1,i+1)
    sns.set_style("whitegrid")
    sns.violinplot(data[col])
    i+=1
    
plt.show()

apach=['glucose_apache','heart_rate_apache','hematocrit_apache','intubated_apache','map_apache']

#Countplot on above Columns
plt.figure(figsize=(20,20))
i=0
for col in apach:
    plt.subplot(3,2,i+1)
    sns.set_style("whitegrid")
    sns.boxplot(data[col])
    i+=1
    
plt.show()

sns.set_style("whitegrid")
sns.countplot(data['intubated_apache'])
plt.show()

apa=['paco2_apache','paco2_for_ph_apache','pao2_apache','ph_apache','resprate_apache','sodium_apache','temp_apache','urineoutput_apache','ventilated_apache','wbc_apache']

#Countplot on above Columns
plt.figure(figsize=(20,20))
i=0
for col in apa:
    plt.subplot(4,3,i+1)
    sns.set_style("whitegrid")
    sns.distplot(data[col])
    i+=1
    
plt.show()

disease=['aids','cirrhosis','diabetes_mellitus','hepatic_failure','immunosuppression','leukemia','lymphoma','solid_tumor_with_metastasis']

#Countplot on above Columns
plt.figure(figsize=(20,20))
i=0
for col in disease:
    plt.subplot(3,3,i+1)
    sns.set_style("whitegrid")
    sns.distplot(data[col])
    i+=1
    
plt.show()

plt.figure(figsize = (10,5))
a=data.sort_values('gender',ascending=False)
sns.set_style("whitegrid")
sns.countplot(x = "gender", hue = "hospital_death", data = a, palette='gnuplot')
plt.xticks(rotation = 90)
plt.show()

data.drop('icu_id',axis=1,inplace=True)

#Heatmap
plt.figure(figsize=(40,40))
sns.heatmap(data.corr(),annot=True)
plt.show()

null=100*(data.isnull().sum()/data.shape[0])
null[null>0]

pivot = pd.melt(data, data.describe().columns[0], data.describe().columns[1:])

fig = sns.FacetGrid(pivot, col = 'variable', col_wrap = 3,
                    sharex = False, sharey = False)
fig.map(sns.kdeplot, "value")
plt.show()

import plotly.graph_objs as go
from plotly.subplots import make_subplots
df=data[['weight','hospital_death','bmi']]
df['weight']=df['weight'].round(0)
df['bmi']=df['bmi'].round(0)
weight_death=df[['weight','hospital_death']].groupby('weight').mean().reset_index()
bmi_death=df[['bmi','hospital_death']].groupby('bmi').mean().reset_index()
fig = make_subplots(rows=1, cols=2, shared_yaxes=True)
fig.add_trace(
    go.Scatter(x=weight_death['weight'], y=weight_death['hospital_death'], name="Weight"),
   row=1, col=1
)
fig.add_trace(
    go.Scatter(x=bmi_death['bmi'], y=bmi_death['hospital_death'], name="BMI"),
    row=1, col=2
)
fig.update_layout(
    title_text="<b>impacts of BMI and weight over patients<b>"
)
fig.update_yaxes(title_text="<b>Average Hospital Death")
fig.show()

data.head()

import plotly.express as px
import plotly.offline as py
apache3=data[['age','apache_3j_bodysystem','hospital_death']]
apache3=apache3.groupby(['apache_3j_bodysystem','age']).agg(['size','mean']).reset_index()

apache3['size']=apache3['hospital_death']['size']
apache3['mean']=apache3['hospital_death']['mean']

apache3.drop('hospital_death',axis=1,inplace=True)

systems =list(apache3['apache_3j_bodysystem'].unique())
data1 = []
list_updatemenus = []
for n, s in enumerate(systems):
    visible = [False] * len(systems)
    visible[n] = True
    temp_dict = dict(label = str(s),
                 method = 'update',
                 args = [{'visible': visible},
                         {'title': '<b>'+s+'<b>'}])
    list_updatemenus.append(temp_dict)
    

for s in systems:
    mask = (apache3['apache_3j_bodysystem'].values == s) 
    trace = (dict(visible = False,     
        x = apache3.loc[mask, 'age'],
        y = apache3.loc[mask, 'mean'],
        mode = 'markers',
        marker = {'size':apache3.loc[mask, 'size']/apache3.loc[mask,'size'].sum()*1000,
                 'color':apache3.loc[mask, 'mean'],
                 'showscale': True})
                   )
    data1.append(trace)

data1[0]['visible'] = True    
    
layout = dict(updatemenus=list([dict(buttons= list_updatemenus)]),
              xaxis=dict(title = '<b>Age<b>', range=[min(apache3.loc[:, 'age'])-10, max(apache3.loc[:, 'age']) + 10]),
              yaxis=dict(title = '<b>Average Hospital Death<b>', range=[min(apache3.loc[:, 'mean'])-0.1, max(apache3.loc[:, 'mean'])+0.1]),
              title='<b>Survival Rate<b>' )
fig = dict(data=data1, layout=layout)
py.iplot(fig, filename='update_dropdown')

#drop columns with high null values
dull = ['d1_mbp_invasive_max','d1_mbp_invasive_min','d1_albumin_max','d1_albumin_min','d1_bilirubin_max','d1_bilirubin_min','d1_inr_max','d1_inr_min','d1_lactate_max','d1_lactate_min',
        'h1_diasbp_invasive_max','h1_diasbp_invasive_min','h1_mbp_invasive_max','h1_mbp_invasive_min','h1_albumin_max','h1_albumin_min','h1_bilirubin_max','h1_bilirubin_min','h1_bun_max','h1_bun_min','h1_calcium_max',
        'h1_calcium_min','h1_creatinine_max','h1_creatinine_min','h1_glucose_max','h1_glucose_min','h1_hco3_max','h1_hco3_min','h1_hemaglobin_max','h1_hemaglobin_min','h1_hematocrit_max',
        'h1_hematocrit_min','h1_inr_max','h1_inr_min','h1_lactate_max','h1_lactate_min','h1_platelets_max','h1_platelets_min','h1_potassium_max','h1_potassium_min','h1_sodium_max','h1_sodium_min',
        'h1_wbc_max','h1_wbc_min','h1_arterial_pco2_max','h1_arterial_pco2_min','h1_arterial_ph_max','h1_arterial_ph_min','h1_arterial_po2_max','h1_arterial_po2_min','h1_pao2fio2ratio_max','h1_pao2fio2ratio_min',
        'd1_arterial_pco2_max','d1_arterial_pco2_min','d1_arterial_ph_max','d1_arterial_ph_min','d1_arterial_po2_max','d1_arterial_po2_min','d1_pao2fio2ratio_max','d1_pao2fio2ratio_min']
data = pd.DataFrame(data)
data.drop(dull,axis=1,inplace=True)

data.head()

100*(data.isnull().sum()/data.shape[0])

data.drop(data.columns[data.apply(lambda col: col.isnull().sum()/len(data) > 0.50)], axis=1,inplace=True)

data.dropna(axis=0,how='any',inplace=True)

data.head()

data.isnull().sum()

# Creating a dummy variable for some of the categorical variables and dropping the first one.
dummy = pd.get_dummies(data[['ethnicity','gender','hospital_admit_source','icu_admit_source','icu_stay_type','icu_type','apache_3j_bodysystem','apache_2_bodysystem']],drop_first=True)
# Adding the results to the master dataframe
data = pd.concat([data,dummy],axis=1)

data.head()

cols = ['ethnicity','gender','hospital_admit_source','icu_admit_source','icu_stay_type','icu_type','apache_3j_bodysystem','apache_2_bodysystem']
data.drop(cols,axis=1,inplace=True)

data.shape

X = data.drop('hospital_death',axis=1)
y = data['hospital_death']

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.7 ,test_size = 0.3, random_state=100)

print(X_train.shape)
print(X_test.shape)
print(y_train.shape)
print(y_test.shape)

# Neural network
model = Sequential()
model.add(Dense(16, input_dim=150, activation='relu'))
model.add(Dense(12, activation='relu'))
model.add(Dense(4, activation='softmax'))

#model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
model.compile(optimizer='adam',loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])
# fit the keras model on the dataset
history = model.fit(X_train, y_train, epochs=150, batch_size=10)
# evaluate the keras model
_, accuracy = model.evaluate(X_train, y_train)
print('Accuracy: %.2f' % (accuracy*100))

import matplotlib.pyplot as plt
plt.plot(history.history['accuracy'])
plt.title('Model accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.show()

import matplotlib.pyplot as plt
plt.plot(history.history['loss'])
plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train'], loc='upper left')
plt.show()

scores_test = model.evaluate(X_test, y_test)
print("\n%s: %.2f%%" % (model.metrics_names[1], scores_test[1]*100))

#saving the model
model.save('keras_model.h5')

#loading the model 
from keras.models import load_model
model = load_model('keras_model.h5')

